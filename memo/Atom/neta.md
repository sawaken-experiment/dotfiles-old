* ctrl-leftでタブ移動
* ctrl-gでsingle-selection
* tabでスニペット移動
* ファイルの始点/終点に移動
* 変数削除
* ruby用に, 変数形式の変換
    * Screaming snake case (定数)
    * Camel case (クラス名)
    * snake case (変数名)
    * snake case following @ (インスタンス変数)
    * snake case following $ (グローバル変数)

* ctagのスコープはどうなっている？開いているタブ内のトークンだけ？
* atomの検索、範囲選択どうなってんの？
* ペースト時の挙動どうにかしてくれ
* double-quote, single-quote, back-quoteで囲う/外す/取り替える

* lineGOTOしたい。でもeditor内でテスト実行できれば要らないので、いらないかも。
* フレームワークの該当するコードを探す方法

# まずやること
* staic-syntax-checkerを導入する
* test-frameworkを選び、導入する。editor上からテスト実行できるようにする
* editor上から簡単に動作確認できるようにする

# Object指向こころがけ
## フィールドのアクセス権はなるべく晒さないようにしよう。
* 【理由】そのフィールドがどのような用途で使われることを想定しているのかが自己ドキュメント化されないため。
* 【代案】フィールド値を用いた処理はそのフィールドを持つオブジェクトのメソッドとして定義しよう。

## 基本データ型に特別な意味を持たせるのはやめよう。
* 【例】連想配列など。
* 【理由】クラス定義がドキュメントになるため。静的型付/動的型付問わず、型はドキュメントになる。

## 巨大クラスを作るのはやめよう。
* クラス内のメソッド郡を複数のグループに分類できるような場合は、クラスが複数種類の責務を負ってしまっているかもしれない。
* 【代案】クラス抽象を行おう。

## 2つのモノを1つのクラスで表現するのはやめよう。
* A形式->B形式の変換処理を書くなら、FormatAクラスとFormatBクラスを個別に作ろう。

## 型のマッチングは控えよう。
* 【例】javaの`instanceof`やrubyの`is_a?`


# 自動テストのこころがけ

## 自動テストはコード破壊を防いでくれる。
* リファクタリングはコードを破壊する恐れがあるが、リファクタリングをしないと、コードは日増しに汚くなっていく。
* 自動テストは既存の振る舞いを壊してしまっていないかどうかを教えてくれるおよそ唯一の存在。

## 自動テストは自動ドキュメントになる。
* 自動テストはテスト対象のコードの利用例として参照することができ、コード・リーディングの足がかりとなる。
* 手書きのドキュメントは(古くなって)誤った利用例を示すことがよくあるが、自動テストが示す利用例は必ず動作する。
* ただし、動作はするが非推奨な利用例を示している可能性はある。なので、自動テストも能動的にメンテナンスする必要がある。
