#!/usr/bin/env ruby
# -*- mode: ruby -*-
# メモの全文検索
require 'tempfile'

# TODO
# optparse使う
# テストコードをファイル内に用意する
# -fを廃止。-fで見出しのみを表示する。（リッチなツリー表示）

# Full-text search for .memorandum
class MemoSearch
  module Util
    extend self

    module COL
      RED     = 1
      GREEN   = 2
      YELLOW  = 3
      BLUE    = 4
      MAGENTA = 5
      CYAN    = 6
    end

    def ansi_colorize(str, color_code = nil, emph_words = [])
      default = "\e[m"
      if color_code
        colorize = "\e[3#{color_code}m"
        linecolorize = "\e[3#{color_code};4m"
      else
        colorize = "\e[m"
        linecolorize = "\e[4m"
      end
      s = str.clone
      emph_words.each do |w|
        s.gsub!(w, "#{linecolorize}\\&#{default}#{colorize}")
      end
      return colorize + s + default
    end
  end

  Section = Struct.new(:fpath, :lines) do
    def to_printing_lines(ws = [])
      printing_lines = []
      printing_lines << Util.ansi_colorize(fpath, Util::COL::CYAN, ws) + "\n"
      quoting = false
      lines.each do |line|
        if line =~ /^```/
          quoting = !quoting
        elsif quoting
          printing_lines << '    ' + Util.ansi_colorize(line, Util::COL::GREEN, ws)
        elsif line =~ /^#/
          printing_lines << '  ' + Util.ansi_colorize(line, Util::COL::YELLOW, ws)
        else
          printing_lines << '  ' + Util.ansi_colorize(line, nil, ws)
        end
      end
      return printing_lines
    end
  end

  def initialize(argv)
    @words = argv.reject{|x| x =~ /^-[a-z]+$/}
    @opts = argv.select{|x| x =~ /^-[a-z]+$/}.map { |x| x[1..-1].chars }.flatten
    @files = Dir.glob("#{ENV['HOME']}/.memorandum/**/*.md")
    @words.map! do |w|
      (@opts.include? 'r') ? Regexp.new(w) : w
    end
    if @words == []
      puts 'usage: m [option] <検索ワード>+'
      puts '  -s 検索結果を標準出力に表示(デフォルトはlessで表示)'
      puts '  -t 見出し文字列のみを検索対象とする'
      puts '  -r 検索ワードを正規表現として扱う'
      puts '  -f 検索ワードにヒットする項目を含むファイル名のみを標準出力に表示する'
      exit(1)
    end
  end

  # TODO
  # ファイル名、上位ブロックテキストも検索のターゲットに含める
  def search
    sections = []
    @files.each do |fpath|
      File.open(fpath, 'r') do |f|
        buf = []
        ws = @words.clone
        f.each_line do |line|
          if line =~ /^#.*/
            if ws == []
              sections << Section.new(fpath, buf.clone)
            end
            buf.clear
            ws = @words.clone
          end
          buf << line
          if !(@opts.include? 't') || line =~ /^#/
            ws.reject!{|w| line.index(w)}
          end
        end
        sections << Section.new(fpath, buf.clone) if ws == []
      end
    end
    return sections
  end

  def print_result(sections, output)
    sections.each_with_index do |section, i|
      output.print "[#{words_str()}:#{i}]"
      section.to_printing_lines(@words).each do |line|
        output.print line
      end
    end
  end

  def words_str
    @words.map{|x| x.inspect}.join(',')
  end

  def process
    sections = search()
    if sections == []
      puts words_str() + 'にヒットするメモはありませんでした'
      exit(0)
    end
    if @opts.include? 'f'
      sections.map(&:fpath).uniq.each do |fpath|
        puts fpath
      end
    elsif @opts.include? 's'
      print_result(sections, STDOUT)
    else
      Tempfile.open(['result', '.md']) do |f|
        print_result(sections, f)
        f.flush
        system("less -fr #{f.path}")
      end
    end
  end
end

MemoSearch.new(ARGV).process()
